/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityScannerFacade.hpp"
#include "flatbuffers/include/syscollector_deltas_generated.h"
#include "flatbuffers/include/syscollector_synchronization_generated.h"
#include "loggerHelper.h"
#include "vulnerability_scanner.h"
#include "wazuh_modules/vulnerability_scanner/src/policyManager/policyManager.hpp"

constexpr auto VULNERABILITY_SCANNER_TEMPLATE = "queue/indexer/vd_states_template.json";
constexpr auto VULNERABILITY_SCANNER_DBSYNC_PATH = "queue/vd/inventory.db";

constexpr auto VD_STATE_DB_STATEMENT {
    R"(CREATE TABLE IF NOT EXISTS vd_state (
    id_cve INTEGER,
    agent_name TEXT,
    node_name TEXT,
    package_name TEXT,
    payload_data TEXT,
    checksum TEXT NOT NULL,
    PRIMARY KEY (id_cve, agent_name, node_name, package_name)) WITHOUT ROWID;)"};

// TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
// LCOV_EXCL_START
void VulnerabilityScannerFacade::start(const nlohmann::json& configuration)
{
    try
    {
        // DBSync initialization
        m_dbsync = std::make_shared<DBSync>(HostType::MANAGER,
                                            DbEngineType::SQLITE3,
                                            VULNERABILITY_SCANNER_DBSYNC_PATH,
                                            VD_STATE_DB_STATEMENT,
                                            DbManagement::PERSISTENT);

        // Policy manager initialization.
        auto& policyManager = PolicyManager::instance();
        policyManager.initialize(configuration);

        // Indexer connector initialization.
        if (policyManager.isIndexerEnabled())
        {
            const auto& indexerConfig = policyManager.getIndexerConfiguration();
            m_indexerConnector =
                std::make_shared<IndexerConnector>(policyManager.getIndexerConfiguration(),
                                                   indexerConfig.contains("template_path")
                                                       ? indexerConfig.at("template_path").get_ref<const std::string&>()
                                                       : VULNERABILITY_SCANNER_TEMPLATE);
        }

        // Database feed manager initialization.
        m_databaseFeedManager = std::make_shared<DatabaseFeedManager>(m_indexerConnector);

        // Add subscribers for policy updates.
        policyManager.addSubscriber(m_databaseFeedManager);

        // Init Orchestrator
        auto scanOrchestrator = std::make_unique<ScanOrchestrator>(m_indexerConnector);

        // Subscription to syscollector delta events.
        m_syscollectorDeltasSubscription =
            std::make_unique<RouterSubscriber>("deltas-syscollector", "vulnerability_scanner_deltas");
        m_syscollectorDeltasSubscription->subscribe(
            [&scanOrchestrator](const std::vector<char>& message)
            {
                std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> data =
                    SyscollectorDeltas::GetDelta(message.data());

                scanOrchestrator->run(data);
            });

        // Subscription to syscollector rsync events.
        m_syscollectorRsyncSubscription =
            std::make_unique<RouterSubscriber>("rsync-syscollector", "vulnerability_scanner_rsync");
        m_syscollectorRsyncSubscription->subscribe(
            [&scanOrchestrator](const std::vector<char>& message)
            {
                std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> data =
                    SyscollectorSynchronization::GetSyncMsg(message.data());

                scanOrchestrator->run(data);
            });
    }
    catch (const std::exception& e)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: " + std::string(e.what()));
    }
    catch (...)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: Unknown exception");
    }
}
// LCOV_EXCL_STOP

void VulnerabilityScannerFacade::stop()
{
    m_indexerConnector.reset();
    m_databaseFeedManager.reset();
    m_syscollectorRsyncSubscription.reset();
    m_syscollectorDeltasSubscription.reset();
    m_dbsync.reset();
    PolicyManager::instance().teardown();
}
