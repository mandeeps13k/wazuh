/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_HPP
#define _DATABASE_FEED_MANAGER_HPP

#include "../policyManager/policyManager.hpp"
#include "../scanOrchestrator/scanContext.hpp"
#include "cacheLRU.hpp"
#include "contentRegister.hpp"
#include "eventDecoder.hpp"
#include "feedIndexer.hpp"
#include "indexerConnector.hpp"
#include "loggerHelper.h"
#include "observer.hpp"
#include "rocksDBWrapper.hpp"
#include "routerSubscriber.hpp"
#include "scanDispatcher.hpp"
#include "storeModel.hpp"
#include "updateCVECandidates.hpp"
#include "updateCVEDescription.hpp"
#include "vulnerabilityCandidate_generated.h"
#include "vulnerabilityDescription_generated.h"
#include "vulnerabilityRemediations_generated.h"
#include "vulnerabilityScanner.hpp"
#include "vulnerabilityTranslationPackages_generated.h"
#include <external/nlohmann/json.hpp>
#include <fstream>
#include <functional>
#include <memory>
#include <string>
#include <vector>

constexpr auto REMEDIATIONS_DATABASE_PATH {"queue/vd/remediations"};
constexpr auto TRANSLATIONS_DATABASE_PATH {"queue/vd/translations"};
constexpr auto CVES_DATABASE_PATH {"queue/vd/cves"};

constexpr auto CACHE_SIZE {2048};

using namespace NSVulnerabilityScanner;

/**
 * @brief A struct for storing a pair of FlatBuffers data.
 *
 * The `FlatbufferDataPair` struct is designed to store a pair of related FlatBuffers data:
 * a `rocksdb::PinnableSlice` containing the serialized data and a pointer to the deserialized
 * data of type `FlatbufferType`. This allows for efficient storage and access to both the raw
 * serialized data and its parsed form.
 *
 * @tparam FlatbufferType The type of the FlatBuffers object that this struct represents.
 */
template<typename FlatbufferType>
struct FlatbufferDataPair final
{
    /**
     * @brief A slice to the serialized FlatBuffers data.
     *
     * The `slice` member stores a `rocksdb::PinnableSlice` that contains the serialized
     * FlatBuffers data.
     */
    rocksdb::PinnableSlice slice;

    /**
     * @brief A pointer to the deserialized FlatBuffers data.
     *
     * The `data` member is a pointer to the deserialized FlatBuffers data of type `FlatbufferType`.
     * It provides direct access to the parsed information.
     */
    const FlatbufferType* data;
};

/**
 * @brief Class to process the message received by the router.
 *
 */
class DatabaseFeedManagerMessageProcessor final
{
public:
    /**
     * @brief Process and validated the message received by the router.
     *
     * @param message Message received by the router.
     * @param orchestration Chain of actions to execute for each valid resource extracted from the message.
     */
    void static processMessage(const std::vector<char>& message,
                               const std::function<void(const nlohmann::json&)>& orchestration)
    {
        auto parsedMessage = nlohmann::json::parse(message, nullptr, false);

        if (parsedMessage.is_discarded() || !parsedMessage.contains("paths"))
        {
            throw std::runtime_error("Invalid message");
        }

        for (const auto& path : parsedMessage.at("paths"))
        {
            auto parsedFile = nlohmann::json::parse(std::ifstream(path), nullptr, false);

            if (parsedFile.is_discarded() || !parsedFile.contains("data"))
            {
                throw std::runtime_error("Invalid file");
            }

            for (const auto& resource : parsedFile.at("data"))
            {
                orchestration(resource);
            }
        }
    }
};

/**
 * @brief DatabaseFeedManager class.
 *
 * @tparam TIndexerConnector Indexer connector type.
 * @tparam TPolicyManager Policy manager type.
 * @tparam TContentRegister Content register type.
 * @tparam TRouterSubscriber Router subscriber type.
 */
template<typename TIndexerConnector = IndexerConnector,
         typename TPolicyManager = PolicyManager,
         typename TContentRegister = ContentRegister,
         typename TRouterSubscriber = RouterSubscriber,
         typename TMessageProcessor = DatabaseFeedManagerMessageProcessor>
class TDatabaseFeedManager final : public Observer<nlohmann::json&>
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     * @param isLocalSubscriber Configures the router subscription lambda execution as local or remote.
     */
    // TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
    // LCOV_EXCL_START
    explicit TDatabaseFeedManager(std::shared_ptr<TIndexerConnector> indexerConnector, bool isLocalSubscriber = true)
        : Observer("database_feed_manager")
        , m_indexerConnector(indexerConnector)
    {
        const auto updaterPolicy = TPolicyManager::instance().getUpdaterConfiguration();
        // Vulnerability content updater initialization.
        m_contentRegistration = std::make_unique<TContentRegister>(
            updaterPolicy.at("topicName"), TPolicyManager::instance().getUpdaterConfiguration());

        m_descriptionsDatabase = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        m_remediationsDatabase = std::make_unique<Utils::RocksDBWrapper>(REMEDIATIONS_DATABASE_PATH);
        m_translationsDatabase = std::make_unique<Utils::RocksDBWrapper>(TRANSLATIONS_DATABASE_PATH);

        m_translationsCache = std::make_unique<LRUCache<std::string, std::string>>(CACHE_SIZE);
        m_cvesDatabase = std::make_unique<Utils::RocksDBWrapper>(CVES_DATABASE_PATH);

        // Subscription to vulnerability detector content update events.
        m_contentUpdateSubscription = std::make_unique<TRouterSubscriber>(
            updaterPolicy.at("topicName"), "vulnerability_feed_manager", isLocalSubscriber);

        m_contentUpdateSubscription->subscribe(
            [&](const std::vector<char>& message)
            {
                auto eventDecoder = std::make_shared<EventDecoder>();
                eventDecoder->setLast(std::make_shared<StoreModel>(
                    m_feedsDatabases, m_descriptionsDatabase.get(), m_remediationsDatabase.get()));
                eventDecoder->setLast(std::make_shared<FeedIndexer<TIndexerConnector>>(m_indexerConnector));
                eventDecoder->setLast(std::make_shared<ScanDispatcher>());

                auto orchestrationLambda = [&](const nlohmann::json& resource)
                {
                    auto eventContext = std::make_shared<EventContext>(
                        EventContext {.message = message, .resource = resource, .cvesDatabase = m_cvesDatabase});
                    eventDecoder->handleRequest(eventContext);
                };
                try
                {
                    logInfo(WM_VULNSCAN_LOGTAG, "Processing message");
                    TMessageProcessor::processMessage(message, orchestrationLambda);
                    logInfo(WM_VULNSCAN_LOGTAG, "Message processed");
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "Error processing message: %s", e.what());
                    // TO DO -> call to reinitialize the database.
                }
            });
    }

    /**
     * @brief Retrieves vulnerability remediation information from the database.
     *
     * This function retrieves remediation information associated with a given CVE ID
     * from the underlying database and stores it in the provided `dtoVulnRemediation`
     * object.
     *
     * @param cveId The CVE ID for which remediation information is requested.
     * @param dtoVulnRemediation A reference to a `FlatbufferDataPair` object
     *        where the retrieved remediation information will be stored.
     *
     * @throws std::runtime_error if the value for the specified `cveId` does not exist
     *         in the database.
     * @throws std::runtime_error if the retrieved data from the database is invalid or
     *         not in the expected FlatBuffers format.
     */
    void getVulnerabilityRemediation(const std::string& cveId, FlatbufferDataPair<RemediationInfo>& dtoVulnRemediation)
    {
        auto result = m_remediationsDatabase->get(cveId, dtoVulnRemediation.slice);

        if (!result)
        {
            throw std::runtime_error("Value for key " + cveId + " does not exist in database.");
        }

        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()),
                                       dtoVulnRemediation.slice.size());
        if (!VerifyRemediationInfoBuffer(verifier))
        {
            throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
        }

        dtoVulnRemediation.data = GetRemediationInfo(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()));
    }

    /**
     * @brief Retrieves a translation for a given package name using the Wazuh package translation system.
     *
     * This function first checks if the translation is available in a cache, and if not, it looks up the translation
     * in a database and caches the result for future use. If a translation is found, the provided callback function
     * is called for each translation entry.
     *
     * @param packageName The name of the package for which translation is needed.
     * @param callback A callback function that will be invoked for each translation entry found.
     *                The callback function should take a single argument of type
     * `NSVulnerabilityScanner::TranslationEntry`.
     *
     * @note This function assumes the existence of several member variables like `m_translationsCache`,
     *       `m_translationsDatabase`, and the necessary data structures and methods, which are used for caching
     *       and querying package translations.
     */
    void
    getWazuhPackageTranslation(const std::string& packageName,
                               const std::function<void(const NSVulnerabilityScanner::TranslationEntry&)>& callback)
    {
        auto resultCache = m_translationsCache->getValue(packageName);

        // If the translation is in the cache, use it to look up the translation in the database.
        if (resultCache.has_value())
        {
            FlatbufferDataPair<TranslationEntry> dtoVulnTranslation;

            auto resultQuery = m_translationsDatabase->get(resultCache.value(), dtoVulnTranslation.slice);
            if (!resultQuery)
            {
                throw std::runtime_error("Value for key " + resultCache.value() + " does not exist in database.");
            }

            flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(dtoVulnTranslation.slice.data()),
                                           dtoVulnTranslation.slice.size());
            if (!VerifyTranslationEntryBuffer(verifier))
            {
                throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
            }

            dtoVulnTranslation.data =
                GetTranslationEntry(reinterpret_cast<const uint8_t*>(dtoVulnTranslation.slice.data()));

            callback(*dtoVulnTranslation.data);
        }

        // If the translation is not in the cache, iterate over all the translations in the database and look for
        // a match.
        for (const auto& [key, value] : m_translationsDatabase->begin())
        {
            flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());
            if (!VerifyTranslationEntryBuffer(verifier))
            {
                throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
            }

            auto queryData = GetTranslationEntry(reinterpret_cast<const uint8_t*>(value.data()));
            std::regex product_pattern {queryData->source()->product()->str()};
            if (std::regex_match(packageName, product_pattern))
            {
                callback(*queryData);

                m_translationsCache->insertKey(packageName, key);
                break;
            }
        }
    }

    /**
     * @brief Get the Vulnerabilities Candidates information.
     *
     * @param cnaName RocksDB table identifier.
     * @param packageName Package name.
     * @param callback Store vulnerability data.
     */
    void getVulnerabilitiesCandidates(
        const std::string& cnaName,
        const std::string& packageName,
        const std::function<bool(const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        if (packageName.empty() || cnaName.empty())
        {
            throw std::runtime_error("Invalid package/cna name.");
        }

        CandidatesDBHelper::findAndOpen(cnaName, m_feedsDatabases, true);

        for (const auto& [key, value] : m_feedsDatabases.at(cnaName)->seek(packageName))
        {
            auto candidateFlatBuffer = GetScanVulnerabilityCandidate(reinterpret_cast<const uint8_t*>(value.data()));
            if (candidateFlatBuffer && callback(*candidateFlatBuffer))
            {
                // If the candidate is vulnerable, we stop looking for.
                break;
            }
        }
    }

    /**
     * @brief Updates scheduler interval.
     *
     * @param data Data containing the interval.
     */
    void update(nlohmann::json& data) override
    {
        m_contentRegistration->changeSchedulerInterval(data.at("updater").at("interval").get<size_t>());
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Gets descriptive information for a cveid.
     *
     * @param cveId cveid to search.
     * @param resultContainer container struct to store the result.
     */
    void getVulnerabiltyDescriptiveInformation(const std::string_view cveId,
                                               FlatbufferDataPair<VulnerabilityDescription>& resultContainer)
    {
        if (m_descriptionsDatabase->get(std::string(cveId), resultContainer.slice) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. Object not found for cveId: " +
                std::string(cveId));
        }

        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                       resultContainer.slice.size());
        if (NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. FlatBuffers verifier failed");
        }

        resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
            NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
    }

private:
    std::unique_ptr<TRouterSubscriber> m_contentUpdateSubscription;
    std::unique_ptr<TContentRegister> m_contentRegistration;
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::unique_ptr<Utils::RocksDBWrapper> m_descriptionsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_remediationsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_translationsDatabase;
    std::unique_ptr<LRUCache<std::string, std::string>> m_translationsCache;
    std::unique_ptr<Utils::RocksDBWrapper> m_cvesDatabase;
    std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>> m_feedsDatabases;
};

using DatabaseFeedManager = TDatabaseFeedManager<>;

#endif // _DATABASE_FEED_MANAGER_HPP
